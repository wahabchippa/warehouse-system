import streamlit as st
from google_auth_oauthlib.flow import Flow
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
import os
import json
from datetime import datetime, date

# ============================================
# PAGE CONFIG
# ============================================
st.set_page_config(
    page_title="WH Operations System",
    page_icon="üì¶",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ============================================
# CONFIGURATION
# ============================================
SCOPES = [
    'https://www.googleapis.com/auth/spreadsheets',
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
    'openid'
]

# Sheet IDs
HANDOVER_SHEET_ID = "1aUfprh_6DwhwVRVKk2PUj_OpeAtz0U_42i5ERTqJfB4"
BUNDLING_SHEET_ID = "1pePWTFWezLEsRQylyHiWhvYh6gpxoEx1DaXfjWXsKEs"

# ============================================
# CUSTOM CSS
# ============================================
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap');
    
    * { font-family: 'Poppins', sans-serif; }
    .stApp { background: #f8fafc; }
    
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    
    .stat-card {
        background: white;
        padding: 25px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.03);
        border-left: 6px solid;
        margin-bottom: 15px;
    }
    .stat-card-primary { border-left-color: #6366f1; }
    .stat-card-orange { border-left-color: #f59e0b; }
    .stat-card-purple { border-left-color: #8b5cf6; }
    .stat-label { font-size: 13px; color: #64748b; font-weight: 700; text-transform: uppercase; }
    .stat-value { font-size: 42px; font-weight: 800; color: #1e293b; }
    
    .order-card {
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.05);
        margin-bottom: 20px;
    }
    .order-id {
        font-size: 32px;
        font-weight: 800;
        color: #1e293b;
        text-align: center;
        margin-bottom: 20px;
    }
    
    .qc-approved {
        background: #dcfce7;
        color: #166534;
        padding: 8px 16px;
        border-radius: 12px;
        font-weight: 700;
        display: inline-block;
    }
    .qc-hold {
        background: #fee2e2;
        color: #991b1b;
        padding: 8px 16px;
        border-radius: 12px;
        font-weight: 700;
        display: inline-block;
    }
    .qc-pending {
        background: #f1f5f9;
        color: #475569;
        padding: 8px 16px;
        border-radius: 12px;
        font-weight: 700;
        display: inline-block;
    }
    
    .detail-item {
        background: white;
        padding: 15px;
        border-radius: 12px;
        border: 1px solid #f1f5f9;
        margin-bottom: 10px;
    }
    .detail-label {
        font-size: 11px;
        text-transform: uppercase;
        color: #94a3b8;
        font-weight: 700;
    }
    .detail-value {
        font-size: 14px;
        font-weight: 600;
        color: #334155;
    }
    
    .alert-orange {
        background: #fff7ed;
        color: #c2410c;
        padding: 15px;
        border-radius: 12px;
        border: 1px solid #fed7aa;
        margin-bottom: 20px;
    }
    .alert-red {
        background: #fef2f2;
        color: #b91c1c;
        padding: 15px;
        border-radius: 12px;
        border: 1px solid #fecaca;
        margin-bottom: 20px;
    }
    .alert-blue {
        background: #eff6ff;
        color: #1d4ed8;
        padding: 15px;
        border-radius: 12px;
        border: 1px solid #bfdbfe;
        margin-bottom: 20px;
    }
    
    .login-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
    }
    .login-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 60px 50px;
        border-radius: 28px;
        text-align: center;
        max-width: 450px;
        box-shadow: 0 25px 60px rgba(0,0,0,0.25);
    }
    .login-title {
        font-size: 24px;
        font-weight: 800;
        color: white;
        margin-bottom: 20px;
    }
    .login-subtitle {
        color: rgba(255,255,255,0.8);
        margin-bottom: 30px;
    }
</style>
""", unsafe_allow_html=True)

# ============================================
# SESSION STATE
# ============================================
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False
if 'user_email' not in st.session_state:
    st.session_state.user_email = None
if 'user_name' not in st.session_state:
    st.session_state.user_name = None
if 'credentials' not in st.session_state:
    st.session_state.credentials = None
if 'current_page' not in st.session_state:
    st.session_state.current_page = "dashboard"
if 'search_result' not in st.session_state:
    st.session_state.search_result = None
if 'selected_match' not in st.session_state:
    st.session_state.selected_match = None

# ============================================
# OAUTH FUNCTIONS
# ============================================
def get_oauth_flow():
    client_config = {
        "web": {
            "client_id": st.secrets["GOOGLE_CLIENT_ID"],
            "client_secret": st.secrets["GOOGLE_CLIENT_SECRET"],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "redirect_uris": [st.secrets["REDIRECT_URI"]]
        }
    }
    
    flow = Flow.from_client_config(
        client_config,
        scopes=SCOPES,
        redirect_uri=st.secrets["REDIRECT_URI"]
    )
    return flow

def get_authorization_url():
    flow = get_oauth_flow()
    auth_url, state = flow.authorization_url(
        access_type='offline',
        include_granted_scopes='true',
        prompt='consent'
    )
    st.session_state.oauth_state = state
    return auth_url

def handle_oauth_callback(code):
    try:
        flow = get_oauth_flow()
        flow.fetch_token(code=code)
        credentials = flow.credentials
        
        # Get user info
        from google.oauth2 import id_token
        from google.auth.transport import requests
        
        user_info_service = build('oauth2', 'v2', credentials=credentials)
        user_info = user_info_service.userinfo().get().execute()
        
        st.session_state.credentials = credentials
        st.session_state.user_email = user_info.get('email')
        st.session_state.user_name = user_info.get('name', user_info.get('email', 'User'))
        st.session_state.authenticated = True
        
        return True
    except Exception as e:
        st.error(f"Authentication error: {str(e)}")
        return False

def get_sheets_service():
    if st.session_state.credentials:
        creds = st.session_state.credentials
        # Refresh if needed
        if creds.expired and creds.refresh_token:
            from google.auth.transport.requests import Request
            creds.refresh(Request())
            st.session_state.credentials = creds
        return build('sheets', 'v4', credentials=creds)
    return None

# ============================================
# SHEET FUNCTIONS
# ============================================
def safe_str(val):
    return "" if val is None else str(val).strip()

def search_order(order_id):
    result = {"found": False, "matches": [], "inBundling": False, "bundlingStatus": ""}
    
    try:
        service = get_sheets_service()
        if not service:
            return result
        
        # Search in Handover Sheet (Inbound Dump tab, headers at row 3, data from row 4)
        sheet = service.spreadsheets()
        
        # Get handover data
        handover_result = sheet.values().get(
            spreadsheetId=HANDOVER_SHEET_ID,
            range="'Inbound Dump'!A3:Z"
        ).execute()
        
        handover_data = handover_result.get('values', [])
        
        if handover_data:
            headers = [str(h).lower() for h in handover_data[0]]
            
            # Find column indices
            col_map = {
                'ord': next((i for i, h in enumerate(headers) if 'order no' in h or 'order #' in h), -1),
                'ven': next((i for i, h in enumerate(headers) if 'vendor' in h), -1),
                'box': next((i for i, h in enumerate(headers) if 'box' in h), -1),
                'qc': next((i for i, h in enumerate(headers) if 'qc status' in h or h == 'qc'), -1),
                'ho': next((i for i, h in enumerate(headers) if 'handedover' in h or 'hand' in h), -1),
                'retool': next((i for i, h in enumerate(headers) if 'retool' in h), -1),
                'hold': next((i for i, h in enumerate(headers) if 'hold zone' in h or h == 'hold'), -1),
                'desc': next((i for i, h in enumerate(headers) if 'description' in h), -1),
                'qcer': next((i for i, h in enumerate(headers) if 'qcer' in h), -1),
                'men': next((i for i, h in enumerate(headers) if 'mentioned' in h), -1),
                'rec': next((i for i, h in enumerate(headers) if 'received' in h), -1),
                'batch': next((i for i, h in enumerate(headers) if 'batch' in h), -1),
                'tm': next((i for i, h in enumerate(headers) if 'tote m' in h), -1),
                'tl': next((i for i, h in enumerate(headers) if 'tote l' in h), -1),
                'txl': next((i for i, h in enumerate(headers) if 'tote xl' in h), -1),
            }
            
            # Search for order
            for i, row in enumerate(handover_data[1:], start=4):  # Data starts from row 4
                if col_map['ord'] >= 0 and col_map['ord'] < len(row):
                    if safe_str(row[col_map['ord']]) == order_id:
                        result['found'] = True
                        
                        def get_val(key):
                            idx = col_map.get(key, -1)
                            if idx >= 0 and idx < len(row):
                                return safe_str(row[idx])
                            return "-"
                        
                        ho_val = get_val('ho').lower()
                        is_done = 'handedover' in ho_val or 'to lm' in ho_val
                        
                        result['matches'].append({
                            'rowNumber': i,
                            'orderNo': get_val('ord'),
                            'batchName': get_val('batch') if get_val('batch') != '-' else 'Main Order',
                            'vendor': get_val('ven'),
                            'box': get_val('box'),
                            'qc': get_val('qc'),
                            'handoverStatus': get_val('ho'),
                            'isHandoverDone': is_done,
                            'retool': get_val('retool'),
                            'qcer': get_val('qcer'),
                            'desc': get_val('desc'),
                            'menQty': get_val('men'),
                            'recQty': get_val('rec'),
                            'hold': get_val('hold'),
                            'toteM': get_val('tm'),
                            'toteL': get_val('tl'),
                            'toteXL': get_val('txl'),
                        })
        
        # Search in Bundling Sheet
        bundling_result = sheet.values().get(
            spreadsheetId=BUNDLING_SHEET_ID,
            range="'Albash working-2'!A1:Z"
        ).execute()
        
        bundling_data = bundling_result.get('values', [])
        
        if bundling_data:
            b_headers = [str(h).lower() for h in bundling_data[0]]
            ord_idx = next((i for i, h in enumerate(b_headers) if 'fleek' in h or 'order id' in h), -1)
            status_idx = next((i for i, h in enumerate(b_headers) if 'packing status' in h), -1)
            
            for row in bundling_data[1:]:
                if ord_idx >= 0 and ord_idx < len(row):
                    if safe_str(row[ord_idx]) == order_id:
                        result['inBundling'] = True
                        if status_idx >= 0 and status_idx < len(row):
                            result['bundlingStatus'] = safe_str(row[status_idx])
                        break
        
    except Exception as e:
        st.error(f"Search error: {str(e)}")
    
    return result

def mark_handover(order_id, action, user_name, row_number):
    try:
        service = get_sheets_service()
        if not service:
            return {"status": "ERROR", "message": "Not authenticated"}
        
        sheet = service.spreadsheets()
        
        # Get headers to find handover column
        headers_result = sheet.values().get(
            spreadsheetId=HANDOVER_SHEET_ID,
            range="'Inbound Dump'!A3:Z3"
        ).execute()
        
        headers = [str(h).lower() for h in headers_result.get('values', [[]])[0]]
        ho_col = next((i for i, h in enumerate(headers) if 'handedover' in h), -1)
        
        if ho_col == -1:
            return {"status": "ERROR", "message": "Handover column not found"}
        
        # Convert column index to letter
        col_letter = chr(65 + ho_col)  # A=0, B=1, etc.
        cell_range = f"'Inbound Dump'!{col_letter}{row_number}"
        
        if action == "MARK":
            # Set value
            sheet.values().update(
                spreadsheetId=HANDOVER_SHEET_ID,
                range=cell_range,
                valueInputOption="RAW",
                body={"values": [["Handedover To LM"]]}
            ).execute()
            
            # Add note with user info
            timestamp = datetime.now().strftime("%d-%b %H:%M")
            note_text = f"‚úÖ Done by: {user_name}\n‚è∞ Time: {timestamp}"
            
            # Notes require batchUpdate
            requests_body = {
                "requests": [{
                    "updateCells": {
                        "range": {
                            "sheetId": 0,  # Assuming first sheet
                            "startRowIndex": row_number - 1,
                            "endRowIndex": row_number,
                            "startColumnIndex": ho_col,
                            "endColumnIndex": ho_col + 1
                        },
                        "rows": [{
                            "values": [{
                                "note": note_text
                            }]
                        }],
                        "fields": "note"
                    }
                }]
            }
            
            # Get sheet ID first
            spreadsheet = sheet.get(spreadsheetId=HANDOVER_SHEET_ID).execute()
            for s in spreadsheet['sheets']:
                if s['properties']['title'] == 'Inbound Dump':
                    requests_body['requests'][0]['updateCells']['range']['sheetId'] = s['properties']['sheetId']
                    break
            
            sheet.batchUpdate(spreadsheetId=HANDOVER_SHEET_ID, body=requests_body).execute()
            
        else:  # REMOVE
            sheet.values().update(
                spreadsheetId=HANDOVER_SHEET_ID,
                range=cell_range,
                valueInputOption="RAW",
                body={"values": [[""]]}
            ).execute()
        
        return {"status": "SUCCESS"}
        
    except Exception as e:
        return {"status": "ERROR", "message": str(e)}

def mark_bundling_hold(order_id, user_name):
    try:
        service = get_sheets_service()
        if not service:
            return {"status": "ERROR", "message": "Not authenticated"}
        
        sheet = service.spreadsheets()
        
        # Get data to find row
        result = sheet.values().get(
            spreadsheetId=BUNDLING_SHEET_ID,
            range="'Albash working-2'!A1:Z"
        ).execute()
        
        data = result.get('values', [])
        if not data:
            return {"status": "ERROR", "message": "No data found"}
        
        headers = [str(h).lower() for h in data[0]]
        ord_idx = next((i for i, h in enumerate(headers) if 'fleek' in h or 'order id' in h), -1)
        status_idx = next((i for i, h in enumerate(headers) if 'packing status' in h), -1)
        
        if ord_idx == -1 or status_idx == -1:
            return {"status": "ERROR", "message": "Columns not found"}
        
        # Find row
        target_row = -1
        for i, row in enumerate(data[1:], start=2):
            if ord_idx < len(row) and safe_str(row[ord_idx]) == order_id:
                target_row = i
                break
        
        if target_row == -1:
            return {"status": "ERROR", "message": "Order not found"}
        
        # Update status
        col_letter = chr(65 + status_idx)
        cell_range = f"'Albash working-2'!{col_letter}{target_row}"
        
        sheet.values().update(
            spreadsheetId=BUNDLING_SHEET_ID,
            range=cell_range,
            valueInputOption="RAW",
            body={"values": [["Hold for Bundling"]]}
        ).execute()
        
        return {"status": "SUCCESS"}
        
    except Exception as e:
        return {"status": "ERROR", "message": str(e)}

def get_pending_list():
    try:
        service = get_sheets_service()
        if not service:
            return []
        
        sheet = service.spreadsheets()
        result = sheet.values().get(
            spreadsheetId=HANDOVER_SHEET_ID,
            range="'Inbound Dump'!A3:Z"
        ).execute()
        
        data = result.get('values', [])
        if not data:
            return []
        
        headers = [str(h).lower() for h in data[0]]
        col_map = {
            'ord': next((i for i, h in enumerate(headers) if 'order no' in h or 'order #' in h), -1),
            'ven': next((i for i, h in enumerate(headers) if 'vendor' in h), -1),
            'box': next((i for i, h in enumerate(headers) if 'box' in h), -1),
            'qc': next((i for i, h in enumerate(headers) if 'qc status' in h or h == 'qc'), -1),
            'ho': next((i for i, h in enumerate(headers) if 'handedover' in h or 'hand' in h), -1),
        }
        
        pending = []
        for row in reversed(data[1:]):
            if len(pending) >= 300:
                break
            
            def get_val(key):
                idx = col_map.get(key, -1)
                if idx >= 0 and idx < len(row):
                    return safe_str(row[idx])
                return ""
            
            ord_val = get_val('ord')
            if not ord_val or 'order no' in ord_val.lower():
                continue
            
            qc = get_val('qc').lower()
            ho = get_val('ho').lower()
            
            is_ready = 'approved' in qc or 'done after resolution' in qc
            is_done = 'handedover' in ho or 'to lm' in ho
            
            if is_ready and not is_done:
                pending.append({
                    'orderNo': ord_val,
                    'vendor': get_val('ven') or '-',
                    'box': get_val('box') or '-',
                    'qc': get_val('qc') or 'QC Pending'
                })
        
        return pending
        
    except Exception as e:
        st.error(f"Error: {str(e)}")
        return []

# ============================================
# LOGIN PAGE
# ============================================
def show_login():
    st.markdown("""
    <div class="login-container">
        <div class="login-box">
            <div style="font-size: 50px; margin-bottom: 20px;">üì¶</div>
            <div class="login-title">WH HANDOVER & BUNDLING</div>
            <div class="login-subtitle">Sign in with your Google account to access the system</div>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Check for OAuth callback
    query_params = st.query_params
    if 'code' in query_params:
        code = query_params['code']
        with st.spinner("Authenticating..."):
            if handle_oauth_callback(code):
                st.query_params.clear()
                st.rerun()
            else:
                st.error("Authentication failed. Please try again.")
    
    # Show login button
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        auth_url = get_authorization_url()
        st.markdown(f"""
        <div style="text-align: center; margin-top: 30px;">
            <a href="{auth_url}" target="_self" style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px 40px;
                border-radius: 12px;
                text-decoration: none;
                font-weight: 700;
                font-size: 16px;
                display: inline-block;
                box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            ">üîê Sign in with Google</a>
        </div>
        """, unsafe_allow_html=True)

# ============================================
# DASHBOARD
# ============================================
def show_dashboard():
    st.markdown("## üìä Dashboard")
    st.caption(f"Welcome, {st.session_state.user_name} ({st.session_state.user_email})")
    
    # Stats (simplified for now)
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div class="stat-card stat-card-primary">
            <div class="stat-label">üìã Today's Handover</div>
            <div class="stat-value">-</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div class="stat-card stat-card-orange">
            <div class="stat-label">‚è∞ Pending</div>
            <div class="stat-value">-</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div class="stat-card stat-card-purple">
            <div class="stat-label">üì¶ Bundling</div>
            <div class="stat-value">-</div>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Search
    st.markdown("### üîç Search & Handover")
    
    col1, col2 = st.columns([4, 1])
    with col1:
        search_id = st.text_input("", placeholder="Scan or enter Order ID...", label_visibility="collapsed")
    with col2:
        search_btn = st.button("üîç Search", use_container_width=True, type="primary")
    
    if search_btn and search_id:
        with st.spinner("Searching..."):
            result = search_order(search_id.strip())
            st.session_state.search_result = result
            if result['found']:
                if len(result['matches']) == 1:
                    st.session_state.selected_match = result['matches'][0]
                else:
                    st.session_state.selected_match = None
            else:
                st.error("‚ùå Order not found")
    
    # Show results
    if st.session_state.search_result and st.session_state.search_result.get('found'):
        show_order_details()

# ============================================
# ORDER DETAILS
# ============================================
def show_order_details():
    result = st.session_state.search_result
    
    # Multiple batches
    if len(result['matches']) > 1 and st.session_state.selected_match is None:
        st.markdown("### üì¶ Multiple Batches Found")
        for i, match in enumerate(result['matches']):
            status = "‚úÖ Done" if match['isHandoverDone'] else "‚è≥ Pending"
            col1, col2, col3 = st.columns([3, 1, 1])
            with col1:
                st.markdown(f"**{match['batchName']}** | Box: {match['box']}")
            with col2:
                st.caption(status)
            with col3:
                if st.button("Select", key=f"batch_{i}"):
                    st.session_state.selected_match = match
                    st.rerun()
        return
    
    match = st.session_state.selected_match
    if not match:
        return
    
    st.markdown("---")
    
    # Order Card
    st.markdown(f"""
    <div class="order-card">
        <div style="text-align: center;">
            <div style="font-size: 12px; color: #94a3b8;">ORDER NUMBER</div>
            <div class="order-id">{match['orderNo']}</div>
            <span style="background: #e0e7ff; color: #4338ca; padding: 6px 12px; border-radius: 30px; font-size: 12px; font-weight: 700;">
                üì¶ {match['batchName']}
            </span>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # QC Status
    qc_raw = (match.get('qc') or '').lower()
    if 'approved' in qc_raw:
        st.markdown('<div style="text-align:center;"><span class="qc-approved">‚úÖ QC APPROVED</span></div>', unsafe_allow_html=True)
    elif 'hold' in qc_raw:
        st.markdown('<div style="text-align:center;"><span class="qc-hold">‚õî QC HOLD</span></div>', unsafe_allow_html=True)
    else:
        st.markdown('<div style="text-align:center;"><span class="qc-pending">‚è≥ PENDING</span></div>', unsafe_allow_html=True)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # Bundling Alert
    if result.get('inBundling'):
        bs = result.get('bundlingStatus', '').lower()
        if 'hold' in bs:
            st.markdown('<div class="alert-red">üîí Already on HOLD in bundling</div>', unsafe_allow_html=True)
        else:
            st.markdown('<div class="alert-orange">‚ö†Ô∏è Found in Bundling List</div>', unsafe_allow_html=True)
    
    # Details
    col1, col2 = st.columns(2)
    with col1:
        st.markdown(f'<div class="detail-item"><div class="detail-label">üè™ Vendor</div><div class="detail-value">{match.get("vendor", "-")}</div></div>', unsafe_allow_html=True)
        st.markdown(f'<div class="detail-item"><div class="detail-label">Mentioned Qty</div><div class="detail-value">{match.get("menQty", "-")}</div></div>', unsafe_allow_html=True)
    with col2:
        st.markdown(f'<div class="detail-item"><div class="detail-label">üì¶ Box</div><div class="detail-value">{match.get("box", "-")}</div></div>', unsafe_allow_html=True)
        st.markdown(f'<div class="detail-item"><div class="detail-label">Received Qty</div><div class="detail-value">{match.get("recQty", "-")}</div></div>', unsafe_allow_html=True)
    
    st.markdown(f'<div class="detail-item"><div class="detail-label">üìù Description</div><div class="detail-value">{match.get("desc", "-")}</div></div>', unsafe_allow_html=True)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # Action Buttons
    col1, col2, col3 = st.columns(3)
    
    is_done = match.get('isHandoverDone', False)
    qc_ok = 'approved' in qc_raw or 'resolution' in qc_raw
    is_hold = 'hold' in qc_raw
    
    with col1:
        if not is_done:
            if st.button("‚úÖ MARK HANDOVER", use_container_width=True, type="primary", disabled=is_hold or not qc_ok):
                with st.spinner("Marking..."):
                    res = mark_handover(
                        match['orderNo'], 
                        "MARK", 
                        st.session_state.user_name,
                        match['rowNumber']
                    )
                    if res['status'] == 'SUCCESS':
                        st.success("‚úÖ Handover Marked!")
                        st.session_state.search_result = None
                        st.session_state.selected_match = None
                        st.rerun()
                    else:
                        st.error(f"Error: {res.get('message')}")
    
    with col2:
        if result.get('inBundling') and 'hold' not in result.get('bundlingStatus', '').lower():
            if st.button("‚è∏Ô∏è HOLD BUNDLING", use_container_width=True):
                with st.spinner("Marking..."):
                    res = mark_bundling_hold(match['orderNo'], st.session_state.user_name)
                    if res['status'] == 'SUCCESS':
                        st.success("‚è∏Ô∏è Marked for Bundling!")
                        st.rerun()
                    else:
                        st.error(f"Error: {res.get('message')}")
    
    with col3:
        if is_done:
            if st.button("üóëÔ∏è REMOVE", use_container_width=True):
                with st.spinner("Removing..."):
                    res = mark_handover(
                        match['orderNo'],
                        "REMOVE",
                        st.session_state.user_name,
                        match['rowNumber']
                    )
                    if res['status'] == 'SUCCESS':
                        st.success("üóëÔ∏è Removed!")
                        st.session_state.search_result = None
                        st.session_state.selected_match = None
                        st.rerun()
                    else:
                        st.error(f"Error: {res.get('message')}")

# ============================================
# PENDING LIST
# ============================================
def show_pending():
    st.markdown("## ‚è∞ Pending Handover")
    
    with st.spinner("Loading..."):
        data = get_pending_list()
    
    st.markdown(f"**Total: {len(data)}**")
    
    if data:
        search = st.text_input("üîç Search...", key="pending_search")
        
        filtered = data
        if search:
            filtered = [d for d in data if search.lower() in str(d).lower()]
        
        for item in filtered:
            col1, col2, col3, col4 = st.columns([2, 2, 1, 2])
            with col1:
                st.markdown(f"**{item['orderNo']}**")
            with col2:
                st.caption(item['vendor'])
            with col3:
                st.caption(item['box'])
            with col4:
                st.markdown(":green[‚úÖ Approved]" if 'approved' in item['qc'].lower() else item['qc'])
            st.markdown("---")
    else:
        st.info("No pending orders")

# ============================================
# MAIN APP
# ============================================
def main():
    if not st.session_state.authenticated:
        show_login()
        return
    
    # Sidebar
    with st.sidebar:
        st.markdown("""
        <div style="text-align: center; padding: 20px;">
            <div style="font-size: 30px;">üì¶</div>
            <div style="font-weight: 800; color: #6366f1;">WH SYSTEM</div>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown("---")
        
        if st.button("üìä Dashboard", use_container_width=True):
            st.session_state.current_page = "dashboard"
            st.session_state.search_result = None
            st.session_state.selected_match = None
            st.rerun()
        
        if st.button("‚è∞ Pending", use_container_width=True):
            st.session_state.current_page = "pending"
            st.rerun()
        
        st.markdown("---")
        
        st.caption(f"üë§ {st.session_state.user_name}")
        st.caption(f"üìß {st.session_state.user_email}")
        
        if st.button("üö™ Logout", use_container_width=True):
            st.session_state.authenticated = False
            st.session_state.credentials = None
            st.session_state.user_email = None
            st.session_state.user_name = None
            st.rerun()
    
    # Main content
    if st.session_state.current_page == "dashboard":
        show_dashboard()
    elif st.session_state.current_page == "pending":
        show_pending()

if __name__ == "__main__":
    main()
